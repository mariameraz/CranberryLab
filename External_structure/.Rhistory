for (i in 1:nrow(features_with_labels)) {
label <- features_with_labels$Label[i]  # Etiqueta
x <- features_with_labels$s.cx[i]  # Coordenada X del centroide
y <- features_with_labels$s.cy[i]  # Coordenada Y del centroide
# Dibujar rectángulo negro detrás del texto
rect(
x - 10, y - 10, x + 10, y + 10,
col = "black", border = NA
)
# Añadir texto en el centro del rectángulo
text(
x, y, labels = as.character(label),
col = "white", cex = 0.8, font = 2
)
}
# Guardar y cerrar el dispositivo gráfico
dev.off()
cat("Imagen guardada en:", output_path, "\n")
colnames(features_shape)
# Convert Pixels to cm
dpi <- 600
pixels_per_cm <- dpi/2.54
pixels_to_cm <- function(pixels) {
return(pixels/pixels_per_cm)
}
# Ejemplo: Convertir características a centímetros
features_shape_cm <- data.frame(
s.area = features_shape$s.area / (pixels_per_cm^2),  # Área en cm²
s.perimeter = features_shape$s.perimeter / pixels_per_cm,  # Perímetro en cm
s.radius.mean = features_shape$s.radius.mean / pixels_per_cm,  # Radio promedio en cm
s.radius.sd = features_shape$s.radius.sd / pixels_per_cm,  # Desviación del radio en cm
s.radius.min = features_shape$s.radius.min / pixels_per_cm,  # Radio mínimo en cm
s.radius.max = features_shape$s.radius.max / pixels_per_cm   # Radio máximo en cm
)
features_shape <- as.data.frame(features_shape)
# Ejemplo: Convertir características a centímetros
features_shape_cm <- data.frame(
s.area = features_shape$s.area / (pixels_per_cm^2),  # Área en cm²
s.perimeter = features_shape$s.perimeter / pixels_per_cm,  # Perímetro en cm
s.radius.mean = features_shape$s.radius.mean / pixels_per_cm,  # Radio promedio en cm
s.radius.sd = features_shape$s.radius.sd / pixels_per_cm,  # Desviación del radio en cm
s.radius.min = features_shape$s.radius.min / pixels_per_cm,  # Radio mínimo en cm
s.radius.max = features_shape$s.radius.max / pixels_per_cm   # Radio máximo en cm
)
print(features_shape_cm)
# Convert Pixels to cm
dpi <- 300
pixels_per_cm <- dpi/2.54
pixels_to_cm <- function(pixels) {
return(pixels/pixels_per_cm)
}
features_shape <- as.data.frame(features_shape)
# Ejemplo: Convertir características a centímetros
features_shape_cm <- data.frame(
s.area = features_shape$s.area / (pixels_per_cm^2),  # Área en cm²
s.perimeter = features_shape$s.perimeter / pixels_per_cm,  # Perímetro en cm
s.radius.mean = features_shape$s.radius.mean / pixels_per_cm,  # Radio promedio en cm
s.radius.sd = features_shape$s.radius.sd / pixels_per_cm,  # Desviación del radio en cm
s.radius.min = features_shape$s.radius.min / pixels_per_cm,  # Radio mínimo en cm
s.radius.max = features_shape$s.radius.max / pixels_per_cm   # Radio máximo en cm
)
print(features_shape_cm)
# 1. Cargar la imagen
image <- readImage('PDF/Image_Test.jpg')
# 2. Convertir la imagen a escala de grises
gray <- channel(image, 'gray')
# 3. Invertir la imagen (si es necesario)
inverted <- 1 - gray
display(inverted, title = "Imagen Invertida")
display(smoothed, title = "Imagen Suavizada")
# 5. Etiquetar regiones conectadas
labeled <- bwlabel(smoothed > 0.1)  # Umbral binario ajustado
display(colorLabels(labeled), title = "Regiones Etiquetadas")
# 6. Eliminar regiones pequeñas (ruido)
features <- computeFeatures.shape(labeled)
summary(features)
min_area <- 100  # Cambia según el tamaño esperado de los objetos
filtered <- rmObjects(labeled, which(features[, "s.area"] < min_area))
display(colorLabels(filtered), title = "Regiones Filtradas")
# 7. Verificar las características de las regiones filtradas
features_shape <- computeFeatures.shape(filtered)
features_moment <- computeFeatures.moment(filtered)
# Combinar ambas tablas
features_with_labels <- data.frame(
Label = as.numeric(rownames(features_shape)),  # Etiquetas de los frutos
features_shape,  # Características geométricas
s.cx = features_moment[, "m.cx"],  # Coordenada X del centroide
s.cy = features_moment[, "m.cy"]   # Coordenada Y del centroide
)
# Crear una copia de la imagen filtrada
labeled_image <- colorLabels(filtered)
# Configurar el archivo de salida
output_path <- "./frutos_etiquetados.png"
png(output_path, width = 800, height = 600)  # Ajusta el tamaño según tus necesidades
# Mostrar la imagen etiquetada con colores
display(labeled_image, method = "raster")
# Superponer etiquetas
for (i in 1:nrow(features_with_labels)) {
label <- features_with_labels$Label[i]  # Etiqueta
x <- features_with_labels$s.cx[i]  # Coordenada X del centroide
y <- features_with_labels$s.cy[i]  # Coordenada Y del centroide
# Dibujar rectángulo negro detrás del texto
rect(
x - 10, y - 10, x + 10, y + 10,
col = "black", border = NA
)
# Añadir texto en el centro del rectángulo
text(
x, y, labels = as.character(label),
col = "white", cex = 0.8, font = 2
)
}
# Guardar y cerrar el dispositivo gráfico
dev.off()
cat("Imagen guardada en:", output_path, "\n")
# Convert Pixels to cm
dpi <- 300
pixels_per_cm <- dpi/2.54
# Convert Pixels to cm
dpi <- 600
pixels_per_cm <- dpi/2.54
pixels_to_cm <- function(pixels) {
return(pixels/pixels_per_cm)
}
features_shape <- as.data.frame(features_shape)
# Ejemplo: Convertir características a centímetros
features_shape_cm <- data.frame(
s.area = features_shape$s.area / (pixels_per_cm^2),  # Área en cm²
s.perimeter = features_shape$s.perimeter / pixels_per_cm,  # Perímetro en cm
s.radius.mean = features_shape$s.radius.mean / pixels_per_cm,  # Radio promedio en cm
s.radius.sd = features_shape$s.radius.sd / pixels_per_cm,  # Desviación del radio en cm
s.radius.min = features_shape$s.radius.min / pixels_per_cm,  # Radio mínimo en cm
s.radius.max = features_shape$s.radius.max / pixels_per_cm   # Radio máximo en cm
)
print(features_shape_cm)
display(image)
image_hsv <- rgb2hsv(image)
# Detect color bar (2 cm)
# 2. Convertir a HSV
image_hsv <- rgb2hsv(image)
# 1. Cargar la imagen
image <- readImage('PDF/Image_Test.jpg')
# Detect color bar (2 cm)
# 2. Convertir a HSV
image_hsv <- rgb2hsv(image)
# Detect color bar (2 cm)
# 2. Convertir a HSV
# Separar los canales de la imagen
image_red <- channel(image, "red")
image_green <- channel(image, "green")
image_blue <- channel(image, "blue")
# Convertir a HSV manualmente
image_hsv <- rgb2hsv(
red = as.numeric(image_red),
green = as.numeric(image_green),
blue = as.numeric(image_blue)
)
image_red
# Detect color bar (2 cm)
# Rojo tiene altos valores en el canal R y bajos en G y B
red_mask <- channel(image, "red") > 0.5 &  # Alto valor en rojo
channel(image, "green") < 0.3 &  # Bajo valor en verde
channel(image, "blue") < 0.3     # Bajo valor en azul
# Mostrar la máscara para verificar
display(red_mask, title = "Máscara de Rojo")
display(image)
# Aplicar un umbral para resaltar la barra roja
binary <- gray < 0.5  # Ajusta el umbral según el brillo de la barra roja
binary
# Detectar regiones conectadas
labeled <- bwlabel(binary)
features <- computeFeatures.shape(labeled)
# Filtrar la región más cercana a la parte inferior (barra roja)
# Suponemos que la barra está cerca del borde inferior
bar_candidate <- which(features[, "s.area"] > 50 & features[, "s.perimeter"] > 50)  # Ajusta los valores
bar_region <- labeled == bar_candidate
# Mostrar la región detectada
display(colorLabels(bar_region), title = "Barra Roja Detectada")
# Calcular longitud en píxeles
bar_length_pixels <- max(features[bar_candidate, "s.perimeter"])
# Calcular píxeles por cm (la barra mide 2 cm)
pixels_per_cm <- bar_length_pixels / 2
# Calcular longitud en píxeles
bar_length_pixels <- max(features[bar_candidate, "s.perimeter"])
# Calcular píxeles por cm (la barra mide 2 cm)
pixels_per_cm <- bar_length_pixels / 2
cat("Píxeles por cm:", pixels_per_cm, "\n")
# Mostrar la región detectada
display(colorLabels(bar_region), title = "Barra Roja Detectada")
# Aplicar un umbral para resaltar la barra roja
binary <- gray < 0.5  # Ajusta el umbral según el brillo de la barra roja
# Detectar regiones conectadas
labeled <- bwlabel(binary)
features <- computeFeatures.shape(labeled)
# Filtrar la región más cercana a la parte inferior (barra roja)
# Suponemos que la barra está cerca del borde inferior
bar_candidate <- which(features[, "s.area"] > 50 & features[, "s.perimeter"] > 50)  # Ajusta los valores
bar_region <- labeled == bar_candidate
# Aplicar un umbral para resaltar la barra roja
binary <- gray < 0.5  # Ajusta el umbral según el brillo de la barra roja
# Detectar regiones conectadas
labeled <- bwlabel(binary)
features <- computeFeatures.shape(labeled)
# Filtrar la región más cercana a la parte inferior (barra roja)
# Suponemos que la barra está cerca del borde inferior
bar_candidate <- which(features[, "s.area"] > 50 & features[, "s.perimeter"] > 50)  # Ajusta los valores
bar_region <- labeled == bar_candidate
# Filtrar el candidato más adecuado (suponiendo que queremos el de mayor área)
if (length(bar_candidate) > 1) {
bar_candidate <- bar_candidate[which.max(features[bar_candidate, "s.area"])]
}
# Filtrar el candidato más adecuado (suponiendo que queremos el de mayor área)
if (length(bar_candidate) > 1) {
bar_candidate <- bar_candidate[which.max(features[bar_candidate, "s.area"])]
}
bar_region <- labeled == bar_candidate
# Filtrar la región más cercana a la parte inferior (barra roja)
# Suponemos que la barra está cerca del borde inferior
bar_candidate <- which(features[, "s.area"] > 50 & features[, "s.perimeter"] > 50)  # Ajusta los valores
# Detectar regiones conectadas
labeled <- bwlabel(binary)
features <- computeFeatures.shape(labeled)
# Filtrar el candidato más adecuado (suponiendo que queremos el de mayor área)
if (length(bar_candidate) > 1) {
bar_candidate <- bar_candidate[which.max(features[bar_candidate, "s.area"])]
}
# Filtrar la región más cercana a la parte inferior (barra roja)
# Suponemos que la barra está cerca del borde inferior
bar_candidate <- which(features[, "s.area"] > 50 & features[, "s.perimeter"] > 50)  # Ajusta los valores
bar_region <- labeled == bar_candidate
# Eliminar ruido (suavizar la imagen)
binary <- opening(binary, makeBrush(5, shape = "disc"))
# Etiquetar las regiones conectadas
labeled <- bwlabel(binary)
# Calcular características de las regiones
features <- computeFeatures.shape(labeled)
# Filtrar regiones rectangulares en la parte inferior de la imagen
# Supongamos que la barra tiene un área y un perímetro grandes
bar_candidate <- which(
features[, "s.area"] > 500 &  # Área mínima de la barra
features[, "s.perimeter"] > 100 &  # Perímetro mínimo
features[, "s.radius.min"] / features[, "s.radius.max"] > 0.8  # Relación aspecto casi rectangular
)
# Identificar la región más baja en la imagen
if (length(bar_candidate) > 1) {
bar_candidate <- bar_candidate[which.max(features[bar_candidate, "s.cy"])]  # Más cercana a la parte inferior
}
# Identificar la región más baja en la imagen
if (length(bar_candidate) > 1) {
bar_candidate <- bar_candidate[which.max(features[bar_candidate, "s.cy"])]  # Más cercana a la parte inferior
}
# Calcular características de las regiones
features <- computeFeatures.moment(labeled)
# Filtrar regiones rectangulares en la parte inferior de la imagen
# Supongamos que la barra tiene un área y un perímetro grandes
bar_candidate <- which(
features[, "s.area"] > 500 &  # Área mínima de la barra
features[, "s.perimeter"] > 100 &  # Perímetro mínimo
features[, "s.radius.min"] / features[, "s.radius.max"] > 0.8  # Relación aspecto casi rectangular
)
features_bar_shape <- computeFeatures.shape(labeled)
# Combinar ambas tablas
features_with_labels_bar <- data.frame(
Label = as.numeric(rownames(features_shape)),  # Etiquetas de los frutos
features_shape,  # Características geométricas
s.cx = features_moment[, "m.cx"],  # Coordenada X del centroide
s.cy = features_moment[, "m.cy"]   # Coordenada Y del centroide
)
# Combinar ambas tablas
features_with_labels_bar <- data.frame(
Label = as.numeric(rownames(features_shape)),  # Etiquetas de los frutos
features_shape,  # Características geométricas
s.cx = features_moment[, "m.cx"],  # Coordenada X del centroide
s.cy = features_moment[, "m.cy"]   # Coordenada Y del centroide
)
# Combinar ambas tablas
features_with_labels_bar <- data.frame(
Label = as.numeric(rownames(features_bar_shape)),  # Etiquetas de los frutos
features_bar_shape,  # Características geométricas
s.cx = features_bar_mom[, "m.cx"],  # Coordenada X del centroide
s.cy = features_bar_mom[, "m.cy"]   # Coordenada Y del centroide
)
# Calcular características de las regiones
features_bar_mom <- computeFeatures.moment(labeled)
features_bar_shape <- computeFeatures.shape(labeled)
# Combinar ambas tablas
features_with_labels_bar <- data.frame(
Label = as.numeric(rownames(features_bar_shape)),  # Etiquetas de los frutos
features_bar_shape,  # Características geométricas
s.cx = features_bar_mom[, "m.cx"],  # Coordenada X del centroide
s.cy = features_bar_mom[, "m.cy"]   # Coordenada Y del centroide
)
# Filtrar regiones rectangulares en la parte inferior de la imagen
# Supongamos que la barra tiene un área y un perímetro grandes
bar_candidate <- which(
features_with_labels_bar[, "s.area"] > 500 &  # Área mínima de la barra
features_with_labels_bar[, "s.perimeter"] > 100 &  # Perímetro mínimo
features_with_labels_bar[, "s.radius.min"] / features_with_labels_bar[, "s.radius.max"] > 0.8  # Relación aspecto casi rectangular
)
bar_candidate <- bar_candidate[which.max(features_with_labels_bar[bar_candidate, "s.cy"])]  # Más cercana a la parte inferior
# Crear la máscara de la barra roja
bar_region <- labeled == bar_candidate
# Mostrar la región detectada
display(colorLabels(bar_region), title = "Barra Roja Detectada")
# Eliminar ruido (suavizar la imagen)
binary <- opening(binary, makeBrush(5, shape = "disc"))
# Etiquetar las regiones conectadas
labeled <- bwlabel(binary)
# Calcular características de las regiones
features_bar_mom <- computeFeatures.moment(labeled)
features_bar_shape <- computeFeatures.shape(labeled)
# Combinar ambas tablas
features_with_labels_bar <- data.frame(
Label = as.numeric(rownames(features_bar_shape)),  # Etiquetas de los frutos
features_bar_shape,  # Características geométricas
s.cx = features_bar_mom[, "m.cx"],  # Coordenada X del centroide
s.cy = features_bar_mom[, "m.cy"]   # Coordenada Y del centroide
)
# Filtrar regiones rectangulares en la parte inferior de la imagen
# Supongamos que la barra tiene un área y un perímetro grandes
bar_candidate <- which(
features_with_labels_bar[, "s.area"] > 500 &  # Área mínima de la barra
features_with_labels_bar[, "s.perimeter"] > 100 &  # Perímetro mínimo
features_with_labels_bar[, "s.radius.min"] / features_with_labels_bar[, "s.radius.max"] > 0.8  # Relación aspecto casi rectangular
)
# Identificar la región más baja en la imagen
if (length(bar_candidate) > 1) {
bar_candidate <- bar_candidate[which.max(features_with_labels_bar[bar_candidate, "s.cy"])]  # Más cercana a la parte inferior
}
# Crear la máscara de la barra roja
bar_region <- labeled == bar_candidate
# Mostrar la
# Mostrar la región detectada
display(colorLabels(bar_region), title = "Barra Roja Detectada")
# Calcular la longitud de la barra en píxeles
bar_length_pixels <- features_with_labels_bar[bar_candidate, "s.perimeter"]
bar_length_pixels
# 1. Cargar la imagen
image <- readImage('PDF/Image_Test.jpg')
# 2. Convertir la imagen a escala de grises
gray <- channel(image, 'gray')
# 3. Invertir la imagen (si es necesario)
inverted <- 1 - gray
display(inverted, title = "Imagen Invertida")
# 4. Suavizar la imagen para reducir ruido (Filtro Gaussiano)
smoothed <- gblur(inverted, sigma = 0.5)  # Ajusta sigma según la cantidad de ruido
display(smoothed, title = "Imagen Suavizada")
# Eliminar ruido (suavizar la imagen)
binary <- opening(binary, makeBrush(5, shape = "disc"))
labeled <- bwlabel(binary)
# Calcular características de las regiones
features_bar_mom <- computeFeatures.moment(labeled)
features_bar_shape <- computeFeatures.shape(labeled)
# Combinar ambas tablas
features_with_labels_bar <- data.frame(
Label = as.numeric(rownames(features_bar_shape)),  # Etiquetas de los frutos
features_bar_shape,  # Características geométricas
s.cx = features_bar_mom[, "m.cx"],  # Coordenada X del centroide
s.cy = features_bar_mom[, "m.cy"]   # Coordenada Y del centroide
)
# Filtrar regiones rectangulares en la parte inferior de la imagen
# Supongamos que la barra tiene un área y un perímetro grandes
bar_candidate <- which(
features_with_labels_bar[, "s.area"] > 500 &  # Área mínima de la barra
features_with_labels_bar[, "s.perimeter"] > 100 &  # Perímetro mínimo
features_with_labels_bar[, "s.radius.min"] / features_with_labels_bar[, "s.radius.max"] > 0.8  # Relación aspecto casi rectangular
)
# Identificar la región más baja en la imagen
if (length(bar_candidate) > 1) {
bar_candidate <- bar_candidate[which.max(features_with_labels_bar[bar_candidate, "s.cy"])]  # Más cercana a la parte inferior
}
# Crear la máscara de la barra roja
bar_region <- labeled == bar_candidate
# Mostrar la región detectada
display(colorLabels(bar_region), title = "Barra Roja Detectada")
# Eliminar ruido (suavizar la imagen)
binary <- gray < 0.3
display(binary)
# Eliminar ruido (suavizar la imagen)
binary <- gray < 0.1
display(binary)
# Eliminar ruido (suavizar la imagen)
binary <- gray < 10
display(binary)
# Eliminar ruido (suavizar la imagen)
binary <- gray < 5
display(binary)
# Eliminar ruido (suavizar la imagen)
binary <- gray < 1
display(binary)
# Eliminar ruido (suavizar la imagen)
binary <- gray < 0.8
display(binary)
binary <- opening(binary, makeBrush(5, shape = "disc"))
labeled <- bwlabel(binary)
# Calcular características de las regiones
features_bar_mom <- computeFeatures.moment(labeled)
features_bar_shape <- computeFeatures.shape(labeled)
# Combinar ambas tablas
features_with_labels_bar <- data.frame(
Label = as.numeric(rownames(features_bar_shape)),  # Etiquetas de los frutos
features_bar_shape,  # Características geométricas
s.cx = features_bar_mom[, "m.cx"],  # Coordenada X del centroide
s.cy = features_bar_mom[, "m.cy"]   # Coordenada Y del centroide
)
# Filtrar regiones rectangulares en la parte inferior de la imagen
# Supongamos que la barra tiene un área y un perímetro grandes
bar_candidate <- which(
features_with_labels_bar[, "s.area"] > 500 &  # Área mínima de la barra
features_with_labels_bar[, "s.perimeter"] > 100 &  # Perímetro mínimo
features_with_labels_bar[, "s.radius.min"] / features_with_labels_bar[, "s.radius.max"] > 0.8  # Relación aspecto casi rectangular
)
# Identificar la región más baja en la imagen
if (length(bar_candidate) > 1) {
bar_candidate <- bar_candidate[which.max(features_with_labels_bar[bar_candidate, "s.cy"])]  # Más cercana a la parte inferior
}
# Crear la máscara de la barra roja
bar_region <- labeled == bar_candidate
# Mostrar la región detectada
display(colorLabels(bar_region), title = "Barra Roja Detectada")
install.packages("reticulate")
library(reticulate)
## Connect python
use_virtualenv("myenv_ext/")  # Cambia "mi_virtualenv" por tu entorno
py_config()
cv2 <- import(cv2)
cv2 <- import('cv2')
lowcolor <- (0,0,75)
lowcolor = (0,0,75)
lowcolor = tuple(0,0,75)
highcolor <- tuple(255, 255, 255)
lowcolor <- tuple(0,0,75)
# Crear una máscara con el rango de color
mask <- cv2$inRange(hsv_image, lowcolor, highcolor)
# Aplicar la máscara a la imagen original
result <- cv2$bitwise_and(image, image, mask = mask)
# Convertir la imagen a HSV
hsv_image <- cv2$cvtColor(image, cv2$COLOR_BGR2HSV)
np <- import('numpy')
img <- cv2$imread('PDF/Image_Test.jpg')
lowcolor <- tuple(0,0,75)
highcolor <- tuple(255, 255, 255)
# Convertir la imagen a HSV
hsv_image <- cv2$cvtColor(image, cv2$COLOR_BGR2HSV)
# Crear una máscara con el rango de color
mask <- cv2$inRange(hsv_image, lowcolor, highcolor)
# Aplicar la máscara a la imagen original
result <- cv2$bitwise_and(image, image, mask = mask)
# Convertir la imagen a HSV
hsv_image <- cv2$cvtColor(image, cv2$COLOR_BGR2HSV)
# Convertir la imagen a HSV
hsv_image <- cv2$cvtColor(img, cv2$COLOR_BGR2HSV)
# Leer la imagen (asegúrate de que la ruta sea correcta)
img <- cv2$imread('PDF/Image_Test.jpg')
if (is.null(img)) {
stop("La imagen no se pudo cargar. Verifica la ruta del archivo.")
}
lowcolor <- tuple(0,0,75)
highcolor <- tuple(255, 255, 255)
# Convertir la imagen a HSV
hsv_image <- cv2$cvtColor(img, cv2$COLOR_BGR2HSV)
thresh = cv2.inRange(img, lowcolor, highcolor)
thresh <- cv2$inRange(img, lowcolor, highcolor)
thresh
kernel <- np$ones((5,5), np$uint8)
kernel <- np$ones(tuple(5,5), np$uint8)
kernel <- np$ones(tuple(as.integer(5), as.integer(5)), dtype= np$uint8)
# Aplicar MORPH_CLOSE
thresh <- cv2$morphologyEx(thresh, cv2$MORPH_CLOSE, kernel)
# Aplicar MORPH_CLOSE
thresh <- cv2$morphologyEx(thresh, cv2$MORPH_CLOSE, kernel)
gray <- cv2$cvtColor(img, cv2$COLOR_BGR2GRAY)
# Convertir a escala de grises
gray <- cv2$cvtColor(img, cv2$COLOR_BGR2GRAY)
thresh <- cv2$inRange(img, lowcolor, highcolor)
kernel <- np$ones(tuple(as.integer(5), as.integer(5)), dtype= np$uint8)
# Aplicar MORPH_CLOSE
thresh <- cv2$morphologyEx(thresh, cv2$MORPH_CLOSE, kernel)
kernel <- np$ones(tuple(as.integer(5), as.integer(5)), dtype= np$uint8)
kernel <- np$ones(tuple(as.integer(5), as.integer(5)))
# Aplicar MORPH_CLOSE
thresh <- cv2$morphologyEx(thresh, cv2$MORPH_CLOSE, kernel)
thresh <- np$uint8(thresh)
kernel <- np$ones(tuple(as.integer(5), as.integer(5)), dtype= np$uint8)
kernel <- np$ones(tuple(as.integer(5), as.integer(5)), dtype= np$uint8)
# Aplicar MORPH_CLOSE
thresh <- cv2$morphologyEx(thresh, cv2$MORPH_CLOSE, kernel)
thresh <- cv2$inRange(img, lowcolor, highcolor)
kernel <- np$ones(tuple(as.integer(5), as.integer(5)), dtype= np$uint8)
# Asegurarte de que 'thresh' está en el formato adecuado
thresh <- np$uint8(thresh)  # Convertir a formato uint8 si es necesario
# Aplicar operación MORPH_CLOSE
thresh <- cv2$morphologyEx(thresh, cv2$MORPH_CLOSE, kernel)
# Leer la imagen
img <- cv2$imread('PDF/Image_Test.jpg')
if (is.null(img)) {
stop("La imagen no se pudo cargar. Verifica la ruta del archivo.")
}
# Crear un umbral binario
lowcolor <- tuple(0, 0, 75)
highcolor <- tuple(255, 255, 255)
thresh <- cv2$inRange(img, lowcolor, highcolor)
# Convertir 'thresh' al formato uint8
thresh <- np$uint8(thresh)
# Crear un kernel
kernel <- np$ones(tuple(as.integer(5), as.integer(5)), dtype = np$uint8)
# Aplicar la operación MORPH_CLOSE
thresh <- cv2$morphologyEx(thresh, cv2$MORPH_CLOSE, kernel)
reticulate::py_last_error()
print(dim(thresh))
print(class(thresh))
print(thresh$dtype)
